<!DOCTYPE html>
<html>
	<head>
		<title>Mission Planner Admin Tool</title>
		<style>
			html, body {
				font-family: Verdana;
				font-size: 10pt;
			}
			
			#step1, #step2 {
				display: none;
			}
			
			#red-pw-td { color: red; }
			#blue-pw-td { color: blue; }
			
			#instance-id-td, #red-pw-td, #blue-pw-td, #admin-pw-td {
				font-family: monospace;
				font-size: 12pt;
				font-weight: bold;
			}
			
			table#instance_info {
				border-radius: 3px;
				border: 3px solid grey;
				padding: 3px;
			}
			
			table#instance_info td.th {
				text-align: right;
				font-weight: 100%;
			}
		</style>
	</head>
	<body>
		<div id="noscript">
			<h2>Enable JavaScript!</h2>
			JavaScript is not enabled. If you are using Internet Explorer, look for a bar at the bottom of the screen that asks you to allow blocked content.
		</div>
		<div id="step-container">
			<div id="step1">
				<h2>Choose a Mission File (.miz)</h2>
				<input type="file" accept="application/zip" id="file-input">
			</div>
			<div id="step2">
				<h2 id="filename-h2"></h2>
				<table style="border-spacing: 40px 2px;">
				<tr><td style="text-align: center"><h3>Create New Instance</h3></td><td style="text-align: center"><h3>Save Mission</h3></td>
				<tr>
				<td id="create_instance_td" style="vertical-align: top;">
					<table>
						<tr><td><input type="checkbox" id="no_passwords-input"><label for="no_passwords-input">Do not set passwords</label></td></tr>
						<tr><td><button id="create-instance-button">Create Instance</button></td></tr>
						<tr><td>&nbsp;</td></tr>
						<tr><td>
							<table id="instance_info" style="visibility: hidden;">
								<tr><td class="th">Instance ID: </td><td id="instance-id-td"></td></tr>
								<tr><td class="th">Red Password: </td><td id="red-pw-td"></td></tr>
								<tr><td class="th">Blue Password: </td><td id="blue-pw-td"></td></tr>
								<tr><td class="th">Admin Password: </td><td id="admin-pw-td"></td></tr>
							</table>
						</td></tr>
					</table>
				</td>
				<td id="save_mission_td" style="vertical-align: top;">
					<table>
						<tr><th>Instance ID:</th><td><input type="text" id="instance_id-input"></td></tr>
						<tr><th>Admin Password:</td><td><input type="text" id="admin_pw-input"></td></tr>
						<tr><th></th><td><button id="save-mission-button">Save Mission</button></td></tr>
						<tr><th></th><td>&nbsp;</td></tr>
						<tr><th>Mission State:</th><td><input type="file" accept="text/plain" id="state-input"></td></tr>
						<tr><th></th><td><button id="upload_mission_state_button">Upload Mission State</button></td></tr>
					</table>
				</td>
				</tr>
				</table>
			</div>
		</div>
		<hr>
		<div id="status"></div>
		<span id="load_mission_lua" style="display: none;">
function load_mission()
	local last_id = 0
	local function new_id()
	   last_id = last_id + 1
		return "0/"..last_id
	end

	local function get_playable_groups(coalition_list)
		local coalition_list = coalition_list or {"red", "blue"}
		
		local playable_groups = {}
		local groupid_to_coalition = {}
		for _, coalition_name in ipairs(coalition_list) do
			local coalition = mission.coalition[coalition_name]
			for _, country in ipairs(coalition.country) do
				if country.plane then
					for _, group in ipairs(country.plane.group) do
						if group.units[1].skill == "Client" then
							playable_groups[#playable_groups+1] = group
							groupid_to_coalition[group.groupId] = coalition_name
						end
					end
				end
				if country.helicopter then
					for _, group in ipairs(country.helicopter.group) do
						if group.units[1].skill == "Client" then
							playable_groups[#playable_groups+1] = group
							groupid_to_coalition[group.groupId] = coalition_name
						end
					end
				end
			end
		end
		return playable_groups, groupid_to_coalition
	end



	local function get_unit_annotations()
		
		local unit_annotations = {}
		for _, coalition_name in ipairs({"red", "blue"}) do
			local coalition = mission.coalition[coalition_name]
			for _, country in ipairs(coalition.country) do
				if country.plane then
					for _, group in ipairs(country.plane.group) do

					end
				end
				if country.helicopter then
					for _, group in ipairs(country.helicopter.group) do

					end
				end
				if country.vehicle then
					for _, group in ipairs(country.vehicle.group) do
						if group.name:match("MP_AIRDEFENCE") then
							unit_annotations[#unit_annotations+1] = {
								["type"] = 'AIRDEFENCE_'..coalition_name,
								["x"] = group.route.points[1].x,
								["z"] = group.route.points[1].y,
							}
						end
						if group.name:match("MP_ARMOR") then
							unit_annotations[#unit_annotations+1] = {
								["type"] = 'ARMOR_'..coalition_name,
								["x"] = group.route.points[1].x,
								["z"] = group.route.points[1].y,
							}
						end
					end
				end

			end
		end
		return unit_annotations
	end



	data = {
	   objects = {},
	   version = 1,
	   briefing = {
		  description = mission.descriptionText,
		  blueTask = mission.descriptionBlueTask,
		  redTask = mission.descriptionRedTask,
	   },
	}

	-- aircraft waypoints
	playable_groups, groupid_to_coalition = get_playable_groups()
	for _, group in ipairs(playable_groups) do
	   
	   local client_acft_route = {
		  id = new_id(),
		  type = "CLIENT_ACFT_ROUTE",
		  group_name = group.name,
		  unittype = group.units[1].type,
		  visibility = groupid_to_coalition[group.groupId]
	   }
	   data.objects[client_acft_route.id] = client_acft_route
	   
	   local prev_wpt = nil
	   for i, point in ipairs(group.route.points) do
		  local wpt = {
			 id = new_id(),
			 type = "CLIENT_ACFT_WAYPOINT",
			 route_id = client_acft_route.id,
			 next_waypoint_id = "",
			 x = point.x,
			 z = point.y,
			 alt_type = point.alt_type,
			 alt = point.alt,
			 name = (point.name or ""),
			 visibility = groupid_to_coalition[group.groupId]
		  }
		  if i == 1 then
			 client_acft_route.first_waypoint_id = wpt.id
		  end
		  data.objects[wpt.id] = wpt
		  if prev_wpt ~= nil then
			 prev_wpt.next_waypoint_id = wpt.id
		  end
		  prev_wpt = wpt
	   end
	end

	-- add unit annotations
	for _, ua in pairs(get_unit_annotations()) do
	   local ann = {
		  id = new_id(),
		  type = "UNIT",
		  unittype = ua.type,
		  x = ua.x,
		  z = ua.z
	   }
	   data.objects[ann.id] = ann
	end

	for _, coa in pairs({"blue", "red"}) do
	   local bullseye = {
		  id = new_id(),
		  type = "BULLSEYE",
		  x = mission.coalition[coa].bullseye.x, 
		  z = mission.coalition[coa].bullseye.y,
		  coalition = coa,
		  visibility = coa,
	   }
	   data.objects[bullseye.id] = bullseye
	end

	ipc_set("data", JSON:encode(data))
end
		</span>
		
		<span id="save_mission_lua" style="display: none;">

function save_impl()



	local function find_heli_or_plane_group(name)
	   for k, coalition_name in pairs({"red", "blue"}) do
		  for country_id=1,#mission.coalition[coalition_name].country do
			 for _, heli_or_plane in pairs({"helicopter", "plane"}) do
				
				if mission.coalition[coalition_name].country[country_id][heli_or_plane] then
				   for group_id=1,#mission.coalition[coalition_name].country[country_id][heli_or_plane].group do
					  if mission.coalition[coalition_name].country[country_id][heli_or_plane].group[group_id].name == name then
						 return coalition_name, country_id, heli_or_plane, group_id
						 --return "mission.coalition."..coalition_name..".country["..country_id.."].plane.group["..group_id.."]"
					  end
				   end
				end
				
			 end
		  end
	   end
	   return nil, nil, nil, nil
	end



	data = JSON:decode(ipc_get("data"))

	local routes = {}
	local second_waypoints_by_group_name = {}
	for _, obj in pairs(data.objects) do
	   if obj.type == "CLIENT_ACFT_ROUTE" then
		  routes[obj.group_name] = obj.id
		  local first_wpt = data.objects[obj.first_waypoint_id]
		  if first_wpt.next_waypoint_id ~= "" then
			 second_waypoints_by_group_name[obj.group_name] = data.objects[first_wpt.next_waypoint_id]
		  end
	   end
	end


	function update_waypoints(group, route, data)
		  -- delete existing waypoints
		  local points = group.route.points
		  for i = #points,2,-1 do
			 points[i] = nil
		  end
		  
		  -- add new waypoints
		  
		  local wpt = second_waypoints_by_group_name[group.name]
		  local i = 2
		  while wpt do
			 local n = i - 2
			 local name = wpt.name
			 if name == "" then name = nil end
			 
			 group.route.points[i] = {
				["x"] = wpt.x,
				["y"] = wpt.z,
				["name"] = name,
				["alt"] = wpt.alt,
				["type"] = "Turning Point",
				["action"] = "Turning Point",
				["alt_type"] = wpt.alt_type,
				["formation_template"] = "",
				["properties"] = {
				   ["vnav"] = 1,
				   ["scale"] = 0,
				   ["angle"] = 0,
				   ["vangle"] = 0,
				   ["steer"] = 2
				},
				["speed"] = 140,
				["ETA_locked"] = false,
				["task"] = {
				   ["id"] = "ComboTask",
				   ["params"] = {["tasks"] = {}}
				},
				["speed_locked"] = true
			 }
			 

			 if wpt.next_waypoint_id == "" then
				wpt = nil
				break
			 else
				wpt = data.objects[wpt.next_waypoint_id]
				i = i + 1
			 end
		  end
	end

	local updated_positions = {}
	local delete_unit = {}
	if data.missionState then
	  for _, pu in pairs(data.missionState.position_updates) do
		updated_positions[pu.unitId] = pu
	  end
	  for _, du in pairs(data.missionState.destroyed_units) do
		delete_unit[du.unitId] = true
	  end
	end

	   for k, coalition_name in pairs({"red", "blue"}) do
		  for country_id=1,#mission.coalition[coalition_name].country do
			 for _, category in pairs({"helicopter", "plane", "vehicle"}) do
				
				if mission.coalition[coalition_name].country[country_id][category] then
				   for group_id=1,#mission.coalition[coalition_name].country[country_id][category].group do
					  local group = mission.coalition[coalition_name].country[country_id][category].group[group_id]
					  
					  if routes[group.name] then
						update_waypoints(group, routes[group.name], data)
					  end
					  
					  local new_units = {}
					  for _, unit in pairs(group.units) do
						local pu = updated_positions[unit.unitId]
						if pu then
						  unit.x = pu.x
						  unit.y = pu.y
						  unit.heading = pu.heading
						end
						if not delete_unit[unit.unitId] then
						  new_units[#new_units+1] = unit
						end
					  end
					  group.units = new_units
					  if #group.units > 0 then
						group.route.points[1].x = group.units[1].x
						group.route.points[1].y = group.units[1].y
					  end
					  
				   end
				end
				
			 end
		  end
	   end

end
save_mission = save_impl
		</span>
		
		<span id="json_lua" style="display: none;">
-- -*- coding: utf-8 -*-
--
-- Copyright 2010-2012 Jeffrey Friedl
-- http://regex.info/blog/
--
local VERSION = 20111207.5  -- version history at end of file
local OBJDEF = { VERSION = VERSION }

--
-- Simple JSON encoding and decoding in pure Lua.
-- http://www.json.org/
--
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
--
--
-- DECODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   If the JSON text is for an object or an array, e.g.
--     { "what": "books", "count": 3 }
--   or
--     [ "Larry", "Curly", "Moe" ]
--
--   the result is a Lua table, e.g.
--     { what = "books", count = 3 }
--   or
--     { "Larry", "Curly", "Moe" }
--
--
--   The encode and decode routines accept an optional second argument, "etc", which is not used
--   during encoding or decoding, but upon error is passed along to error handlers. It can be of any
--   type (including nil).
--
--   With most errors during decoding, this code calls
--
--      JSON:onDecodeError(message, text, location, etc)
--
--   with a message about the error, and if known, the JSON text being parsed and the byte count
--   where the problem was discovered. You can replace the default JSON:onDecodeError() with your
--   own function.
--
--   The default onDecodeError() merely augments the message with data about the text and the
--   location if known (and if a second 'etc' argument had been provided to decode(), its value is
--   tacked onto the message as well), and then calls JSON.assert(), which itself defaults to Lua's
--   built-in assert(), and can also be overridden.
--
--   For example, in an Adobe Lightroom plugin, you might use something like
--
--          function JSON:onDecodeError(message, text, location, etc)
--             LrErrors.throwUserError("Internal Error: invalid JSON data")
--          end
--
--   or even just
--
--          function JSON.assert(message)
--             LrErrors.throwUserError("Internal Error: " .. message)
--          end
--
--   If JSON:decode() is passed a nil, this is called instead:
--
--      JSON:onDecodeOfNilError(message, nil, nil, etc)
--
--   and if JSON:decode() is passed HTML instead of JSON, this is called:
--
--      JSON:onDecodeOfHTMLError(message, text, nil, etc)
--
--   The use of the fourth 'etc' argument allows stronger coordination between decoding and error
--   reporting, especially when you provide your own error-handling routines. Continuing with the
--   the Adobe Lightroom plugin example:
--
--          function JSON:onDecodeError(message, text, location, etc)
--             local note = "Internal Error: invalid JSON data"
--             if type(etc) = 'table' and etc.photo then
--                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
--             end
--             LrErrors.throwUserError(note)
--          end
--
--            :
--            :
--
--          for i, photo in ipairs(photosToProcess) do
--               :             
--               :             
--               local data = JSON:decode(someJsonText, { photo = photo })
--               :             
--               :             
--          end
--
--
--
--

-- DECODING AND STRICT TYPES
--
--   Because both JSON objects and JSON arrays are converted to Lua tables, it's not normally
--   possible to tell which a Lua table came from, or guarantee decode-encode round-trip
--   equivalency.
--
--   However, if you enable strictTypes, e.g.
--
--      JSON = (loadfile "JSON.lua")() --load the routines
--      JSON.strictTypes = true
--
--   then the Lua table resulting from the decoding of a JSON object or JSON array is marked via Lua
--   metatable, so that when re-encoded with JSON:encode() it ends up as the appropriate JSON type.
--
--   (This is not the default because other routines may not work well with tables that have a
--   metatable set, for example, Lightroom API calls.)
--
--
-- ENCODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability

--   On error during encoding, this code calls:
--
--    JSON:onEncodeError(message, etc)
--
--   which you can override in your local JSON object.
--
--
-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
--
--    assert
--    onDecodeError
--    onDecodeOfNilError
--    onDecodeOfHTMLError
--    onEncodeError
--
--  If you want to create a separate Lua JSON object with its own error handlers,
--  you can reload JSON.lua or use the :new() method.
--
---------------------------------------------------------------------------


local author = "-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json), version " .. tostring(VERSION) .. " ]-"
local isArray  = { __tostring = function() return "JSON array"  end }    isArray.__index  = isArray
local isObject = { __tostring = function() return "JSON object" end }    isObject.__index = isObject


function OBJDEF:newArray(tbl)
   return setmetatable(tbl or {}, isArray)
end

function OBJDEF:newObject(tbl)
   return setmetatable(tbl or {}, isObject)
end

local function unicode_codepoint_as_utf8(codepoint)
   --
   -- codepoint is a number
   --
   if codepoint <= 127 then
      return string.char(codepoint)

   elseif codepoint <= 2047 then
      --
      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
      --
      local highpart = math.floor(codepoint / 0x40)
      local lowpart  = codepoint - (0x40 * highpart)
      return string.char(0xC0 + highpart,
                         0x80 + lowpart)

   elseif codepoint <= 65535 then
      --
      -- 1110yyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x1000)
      local remainder = codepoint - 0x1000 * highpart
      local midpart   = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midpart

      highpart = 0xE0 + highpart
      midpart  = 0x80 + midpart
      lowpart  = 0x80 + lowpart

      --
      -- Check for an invalid character (thanks Andy R. at Adobe).
      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
      --
      if ( highpart == 0xE0 and midpart < 0xA0 ) or
         ( highpart == 0xED and midpart > 0x9F ) or
         ( highpart == 0xF0 and midpart < 0x90 ) or
         ( highpart == 0xF4 and midpart > 0x8F )
      then
         return "?"
      else
         return string.char(highpart,
                            midpart,
                            lowpart)
      end

   else
      --
      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x40000)
      local remainder = codepoint - 0x40000 * highpart
      local midA      = math.floor(remainder / 0x1000)
      remainder       = remainder - 0x1000 * midA
      local midB      = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midB

      return string.char(0xF0 + highpart,
                         0x80 + midA,
                         0x80 + midB,
                         0x80 + lowpart)
   end
end

function OBJDEF:onDecodeError(message, text, location, etc)
   if text then
      if location then
         message = string.format("%s at char %d of: %s", message, location, text)
      else
         message = string.format("%s: %s", message, text)
      end
   end
   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

OBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError
OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError

function OBJDEF:onEncodeError(message, etc)
   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

local function grok_number(self, text, start, etc)
   --
   -- Grab the integer part
   --
   local integer_part = text:match('^-?[1-9]%d*', start)
                     or text:match("^-?0",        start)

   if not integer_part then
      self:onDecodeError("expected number", text, start, etc)
   end

   local i = start + integer_part:len()

   --
   -- Grab an optional decimal part
   --
   local decimal_part = text:match('^%.%d+', i) or ""

   i = i + decimal_part:len()

   --
   -- Grab an optional exponential part
   --
   local exponent_part = text:match('^[eE][-+]?%d+', i) or ""

   i = i + exponent_part:len()

   local full_number_text = integer_part .. decimal_part .. exponent_part
   local as_number = tonumber(full_number_text)

   if not as_number then
      self:onDecodeError("bad number", text, start, etc)
   end

   return as_number, i
end


local function grok_string(self, text, start, etc)

   if text:sub(start,start) ~= '"' then
      self:onDecodeError("expected string's opening quote", text, start, etc)
   end

   local i = start + 1 -- +1 to bypass the initial quote
   local text_len = text:len()
   local VALUE = ""
   while i <= text_len do
      local c = text:sub(i,i)
      if c == '"' then
         return VALUE, i + 1
      end
      if c ~= '\\' then
         VALUE = VALUE .. c
         i = i + 1
      elseif text:match('^\\b', i) then
         VALUE = VALUE .. "\b"
         i = i + 2
      elseif text:match('^\\f', i) then
         VALUE = VALUE .. "\f"
         i = i + 2
      elseif text:match('^\\n', i) then
         VALUE = VALUE .. "\n"
         i = i + 2
      elseif text:match('^\\r', i) then
         VALUE = VALUE .. "\r"
         i = i + 2
      elseif text:match('^\\t', i) then
         VALUE = VALUE .. "\t"
         i = i + 2
      else
         local hex = text:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
         if hex then
            i = i + 6 -- bypass what we just read

            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and
            -- followed by another in a specific range, it'll be a two-code surrogate pair.
            local codepoint = tonumber(hex, 16)
            if codepoint >= 0xD800 and codepoint <= 0xDBFF then
               -- it's a hi surrogate... see whether we have a following low
               local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
               if lo_surrogate then
                  i = i + 6 -- bypass the low surrogate we just read
                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
               else
                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.
               end
            end
            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)

         else

            -- just pass through what's escaped
            VALUE = VALUE .. text:match('^\\(.)', i)
            i = i + 2
         end
      end
   end

   self:onDecodeError("unclosed string", text, start, etc)
end

local function skip_whitespace(text, start)

   local match_start, match_end = text:find("^[ \n\r\t]+", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
   if match_end then
      return match_end + 1
   else
      return start
   end
end

local grok_one -- assigned later

local function grok_object(self, text, start, etc)
   if not text:sub(start,start) == '{' then
      self:onDecodeError("expected '{'", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'

   local VALUE = self.strictTypes and self:newObject { } or { }

   if text:sub(i,i) == '}' then
      return VALUE, i + 1
   end
   local text_len = text:len()
   while i <= text_len do
      local key, new_i = grok_string(self, text, i, etc)

      i = skip_whitespace(text, new_i)

      if text:sub(i, i) ~= ':' then
         self:onDecodeError("expected colon", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)

      local val, new_i = grok_one(self, text, i)

      VALUE[key] = val

      --
      -- Expect now either '}' to end things, or a ',' to allow us to continue.
      --
      i = skip_whitespace(text, new_i)

      local c = text:sub(i,i)

      if c == '}' then
         return VALUE, i + 1
      end

      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '}'", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)
   end

   self:onDecodeError("unclosed '{'", text, start, etc)
end

local function grok_array(self, text, start, etc)
   if not text:sub(start,start) == '[' then
      self:onDecodeError("expected '['", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
   local VALUE = self.strictTypes and self:newArray { } or { }
   if text:sub(i,i) == ']' then
      return VALUE, i + 1
   end

   local text_len = text:len()
   while i <= text_len do
      local val, new_i = grok_one(self, text, i)

      table.insert(VALUE, val)

      i = skip_whitespace(text, new_i)

      --
      -- Expect now either ']' to end things, or a ',' to allow us to continue.
      --
      local c = text:sub(i,i)
      if c == ']' then
         return VALUE, i + 1
      end
      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '['", text, i, etc)
      end
      i = skip_whitespace(text, i + 1)
   end
   self:onDecodeError("unclosed '['", text, start, etc)
end


grok_one = function(self, text, start, etc)
   -- Skip any whitespace
   start = skip_whitespace(text, start)

   if start > text:len() then
      self:onDecodeError("unexpected end of string", text, nil, etc)
   end

   if text:find('^"', start) then
      return grok_string(self, text, start, etc)

   elseif text:find('^[-0123456789 ]', start) then
      return grok_number(self, text, start, etc)

   elseif text:find('^%{', start) then
      return grok_object(self, text, start, etc)

   elseif text:find('^%[', start) then
      return grok_array(self, text, start, etc)

   elseif text:find('^true', start) then
      return true, start + 4

   elseif text:find('^false', start) then
      return false, start + 5

   elseif text:find('^null', start) then
      return nil, start + 4

   else
      self:onDecodeError("can't parse JSON", text, start, etc)
   end
end

function OBJDEF:decode(text, etc)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onDecodeError("JSON:decode must be called in method format", nil, nil, etc)
   end

   if text == nil then
      self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"), nil, nil, etc)
   elseif type(text) ~= 'string' then
      self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s", type(text)), nil, nil, etc)
   end

   if text:match('^%s*$') then
      return nil
   end

   if text:match('^%s*<') then
      -- Can't be JSON... we'll assume it's HTML
      self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"), text, nil, etc)
   end

   --
   -- Ensure that it's not UTF-32 or UTF-16.
   -- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
   -- but this package can't handle them.
   --
   if text:sub(1,1):byte() == 0 or (text:len() >= 2 and text:sub(2,2):byte() == 0) then
      self:onDecodeError("JSON package groks only UTF-8, sorry", text, nil, etc)
   end

   local success, value = pcall(grok_one, self, text, 1, etc)
   if success then
      return value
   else
      -- should never get here... JSON parse errors should have been caught earlier
      assert(false, value)
      return nil
   end
end

local function backslash_replacement_function(c)
   if c == "\n" then
      return "\\n"
   elseif c == "\r" then
      return "\\r"
   elseif c == "\t" then
      return "\\t"
   elseif c == "\b" then
      return "\\b"
   elseif c == "\f" then
      return "\\f"
   elseif c == '"' then
      return '\\"'
   elseif c == '\\' then
      return '\\\\'
   else
      return string.format("\\u%04x", c:byte())
   end
end

local chars_to_be_escaped_in_JSON_string
   = '['
   ..    '"'    -- class sub-pattern to match a double quote
   ..    '%\\'  -- class sub-pattern to match a backslash
   ..    '%z'   -- class sub-pattern to match a null
   ..    '\001' .. '-' .. '\031' -- class sub-pattern to match control characters
   .. ']'

local function json_string_literal(value)
   local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
   return '"' .. newval .. '"'
end

local function object_or_array(self, T, etc)
   --
   -- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
   -- object. If there are only numbers, it's a JSON array.
   --
   -- If we'll be converting to a JSON object, we'll want to sort the keys so that the
   -- end result is deterministic.
   --
   local string_keys = { }
   local seen_number_key = false
   local maximum_number_key

   for key in pairs(T) do
      if type(key) == 'number' then
         seen_number_key = true
         if not maximum_number_key or maximum_number_key < key then
            maximum_number_key = key
         end
      elseif type(key) == 'string' then
         table.insert(string_keys, key)
      else
         self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
      end
   end

   if seen_number_key and #string_keys > 0 then
      --
      -- Mixed key types... don't know what to do, so bail
      --
      self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc)

   elseif #string_keys == 0  then
      --
      -- An array
      --
      if seen_number_key then
         return nil, maximum_number_key -- an array
      else
         --
         -- An empty table...
         --
         if tostring(T) == "JSON array" then
            return nil
         elseif tostring(T) == "JSON object" then
            return { }
         else
            -- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
            return nil
         end
      end
   else
      --
      -- An object, so return a list of keys
      --
      table.sort(string_keys)
      return string_keys
   end
end

--
-- Encode
--
local encode_value -- must predeclare because it calls itself
function encode_value(self, value, parents, etc)


   if value == nil then
      return 'null'
   end

   if type(value) == 'string' then
      return json_string_literal(value)
   elseif type(value) == 'number' then
      if value ~= value then
         --
         -- NaN (Not a Number).
         -- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
         --
         return "null"
      elseif value >= math.huge then
         --
         -- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
         -- really be a package option. Note: at least with some implementations, positive infinity
         -- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
         -- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
         -- case first.
         --
         return "1e+9999"
      elseif value <= -math.huge then
         --
         -- Negative infinity.
         -- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
         --
         return "-1e+9999"
      else
         return tostring(value)
      end
   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      else
         parents[T] = true
      end

      local result_value

      local object_keys, maximum_number_key = object_or_array(self, T, etc)
      if maximum_number_key then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, maximum_number_key do
            table.insert(ITEMS, encode_value(self, T[i], parents, etc))
         end

         result_value = "[" .. table.concat(ITEMS, ",") .. "]"
      elseif object_keys then
         --
         -- An object
         --

         --
         -- We'll always sort the keys, so that comparisons can be made on
         -- the results, etc. The actual order is not particularly
         -- important (e.g. it doesn't matter what character set we sort
         -- as); it's only important that it be deterministic... the same
         -- every time.
         --
         local PARTS = { }
         for _, key in ipairs(object_keys) do
            local encoded_key = encode_value(self, tostring(key), parents, etc)
            local encoded_val = encode_value(self, T[key],        parents, etc)
            table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val))
         end
         result_value = "{" .. table.concat(PARTS, ",") .. "}"
      else
         --
         -- An empty array/object... we'll treat it as an array, though it should really be an option
         --
         result_value = "[]"
      end

      parents[T] = false
      return result_value
   end
end

local encode_pretty_value -- must predeclare because it calls itself
function encode_pretty_value(self, value, parents, indent, etc)

   if type(value) == 'string' then
      return json_string_literal(value)

   elseif type(value) == 'number' then
      return tostring(value)

   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) == 'nil' then
      return 'null'

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      end
      parents[T] = true

      local result_value

      local object_keys = object_or_array(self, T, etc)
      if not object_keys then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, #T do
            table.insert(ITEMS, encode_pretty_value(self, T[i], parents, indent, etc))
         end

         result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]"

      else

         --
         -- An object -- can keys be numbers?
         --

         local KEYS = { }
         local max_key_length = 0
         for _, key in ipairs(object_keys) do
            local encoded = encode_pretty_value(self, tostring(key), parents, "", etc)
            max_key_length = math.max(max_key_length, #encoded)
            table.insert(KEYS, encoded)
         end
         local key_indent = indent .. "    "
         local subtable_indent = indent .. string.rep(" ", max_key_length + 2 + 4)
         local FORMAT = "%s%" .. tostring(max_key_length) .. "s: %s"

         local COMBINED_PARTS = { }
         for i, key in ipairs(object_keys) do
            local encoded_val = encode_pretty_value(self, T[key], parents, subtable_indent, etc)
            table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val))
         end
         result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}"
      end

      parents[T] = false
      return result_value
   end
end

function OBJDEF:encode(value, etc)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onEncodeError("JSON:encode must be called in method format", etc)
   end

   local parents = {}
   return encode_value(self, value, parents, etc)
end

function OBJDEF:encode_pretty(value, etc)
   local parents = {}
   local subtable_indent = ""
   return encode_pretty_value(self, value, parents, subtable_indent, etc)
end

function OBJDEF.__tostring()
   return "JSON encode/decode package"
end

OBJDEF.__index = OBJDEF

function OBJDEF:new(args)
   local new = { }

   if args then
      for key, val in pairs(args) do
         new[key] = val
      end
   end

   return setmetatable(new, OBJDEF)
end

JSON = OBJDEF:new()

--
-- Version history:
--
--   20111207.5    Added support for the 'etc' arguments, for better error reporting.
--
--   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
--
--   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
--
--                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
--                     spitting out full arrays, such that
--                        JSON:encode({"one", "two", [10] = "ten"})
--                     returns
--                        ["one","two",null,null,null,null,null,null,null,"ten"]
--
--                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
--
--                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
--                     Version 20100810.2 and earlier created invalid JSON in both cases.
--
--                   * Unicode surrogate pairs are now detected when decoding JSON.
--
--   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
--
--   20100731.1    initial public release
--

		</span>
		
		<span id="dump_lua" style="display: none;">
--[[
This serialization code is taken from prtr-dump.
See http://piratery.net/dump/ for details.
It can be redistributed under the following MIT-style license:

Copyright (c) Jerome Vuarand

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

]]--

do
local _M = {}
local _NAME = ... or 'test'

local io = require 'io'
local os = require 'os'
local table = require 'table'
local string = require 'string'

_M.groupsize = 10000

local dumptablecontent

local tkeys = {
	boolean = true,
	number = true,
	string = true,
}
local tvalues = {
	boolean = true,
	number = true,
	string = true,
	table = true,
}

local function dumptable(table, write, level)
	-- prefix and suffix
	local mt = getmetatable(table)
	local prefix = mt and mt.__dump_prefix
	local suffix = mt and mt.__dump_suffix
	if type(prefix)=='function' then
		prefix = prefix(table)
	end
	prefix = prefix or ""
	if type(suffix)=='function' then
		suffix = suffix(table)
	end
	suffix = suffix or ""
	
	-- count keys
	local nkeys = 0
	for k,v in pairs(table) do
		nkeys = nkeys + 1
		local tk,tv = type(k),type(v)
		if not tkeys[tk] then
			return nil,"unsupported key type '"..tk.."'"
		end
		if not tvalues[tv] then
			return nil,"unsupported value type '"..tv.."'"
		end
	end
	
	-- if too many keys, use multiple closures
	if nkeys > _M.groupsize then
		local success,err
		success,err = write(((prefix..[[
(function()
	local t = { function() return {
]]):gsub("\n", "\n"..("\t"):rep(level))))
		if not success then return nil,err end
		success,err = dumptablecontent(table, write, level+2, _M.groupsize, ("\t"):rep(level+1)..'} end, function() return {\n')
		if not success then return nil,err end
		success,err = write((([[
	} end }
	local result = {}
	for _,f in ipairs(t) do
		for k,v in pairs(f()) do
			result[k] = v
		end
	end
	return result
end)()]]..suffix):gsub("\n", "\n"..("\t"):rep(level))))
		if not success then return nil,err end
		return true
	elseif nkeys==0 then
		local success,err = write(prefix.."{ }"..suffix)
		if not success then return nil,err end
		return true
	else
		local success,err
		success,err = write(prefix.."{\n")
		if not success then return nil,err end
		success,err = dumptablecontent(table, write, level+1)
		if not success then return nil,err end
		success,err = write(("\t"):rep(level).."}"..suffix)
		if not success then return nil,err end
		return true
	end
end

local function dumpvalue(v, write, level)
	local t = type(v)
	if t=='string' then
		return write('"'..v:gsub('[%z\1-\31\127"\\]', function(c)
			if c=='\\' then
				return '\\\\'
			elseif c=='"' then
				return '\\"'
			elseif c=='\t' then
				return '\\t'
			elseif c=='\n' then
				return '\\n'
			elseif c=='\r' then
				return '\\r'
			else
				return string.format('\\%03d', string.byte(c))
			end
		end)..'"')
	elseif t=='number' then
		if v~=v then -- nan
			return write('0/0')
		elseif v==1/0 then -- +inf
			return write('1/0')
		elseif v==-1/0 then -- -inf
			return write('-1/0')
		else
			return write(tostring(v))
		end
	elseif t=='boolean' then
		if v then
			return write('true')
		else
			return write('false')
		end
	elseif t=='nil' then
		return write('nil')
	elseif t=='table' then
		return dumptable(v, write, level)
	else
		return nil,"unsupported value type '"..t.."'"
	end
end

local lua_keywords = {
	['and'] = true,
	['break'] = true,
	['do'] = true,
	['else'] = true,
	['elseif'] = true,
	['end'] = true,
	['false'] = true,
	['for'] = true,
	['function'] = true,
	['if'] = true,
	['in'] = true,
	['local'] = true,
	['nil'] = true,
	['not'] = true,
	['or'] = true,
	['repeat'] = true,
	['return'] = true,
	['then'] = true,
	['true'] = true,
	['until'] = true,
	['while'] = true,
}

local function dumppair(k, v, write, level)
	local success,err
	success,err = write(("\t"):rep(level))
	if not success then return nil,err end
	local assignment = " = "
	local tk = type(k)
	if tk=='string' and k:match("^[_a-zA-Z][_a-zA-Z0-9]*$") and not lua_keywords[k] then
		success,err = write(k)
		if not success then return nil,err end
	elseif tk=='string' or tk=='number' or tk=='boolean' then
		success,err = write('[')
		if not success then return nil,err end
		success,err = dumpvalue(k, write, level)
		if not success then return nil,err end
		success,err = write(']')
		if not success then return nil,err end
	elseif tk=='nil' then
		-- we are in the array part
		assignment = ""
	else
		error("unsupported key type '"..type(k).."'")
	end
	success,err = write(assignment)
	if not success then return nil,err end
	success,err = dumpvalue(v, write, level)
	if not success then return nil,err end
	success,err = write(",\n")
	if not success then return nil,err end
	return true
end

local function keycomp(a, b)
	local ta,tb = type(a),type(b)
	if ta==tb then
		return a < b
	else
		return ta=='string'
	end
end

local tsort = table.sort
local function dumptablesection(table, write, level, keys, state)
	-- sort keys
	local skeys = {}
	for k in pairs(keys) do skeys[#skeys+1] = k end
	tsort(skeys, keycomp)
	-- dump pairs
	for _,k in pairs(skeys) do
		local v = table[k]
		if state then
			state.i = state.i + 1
			if state.i % state.size == 0 then
				local success,err = write(state.sep)
				if not success then return nil,err end
			end
		end
		local success,err = dumppair(k, v, write, level)
		if not success then return nil,err end
	end
	return true
end

local function dumptableimplicitsection(table, write, level, state)
	for k,v in ipairs(table) do
		if state then
			state.i = state.i + 1
			if state.i % state.size == 0 then
				local success,err = write(state.sep)
				if not success then return nil,err end
			end
		end
		local success,err
		if state then
			success,err = dumppair(k, v, write, level)
		else
			success,err = dumppair(nil, v, write, level)
		end
		if not success then return nil,err end
	end
	return true
end

function dumptablecontent(table, write, level, groupsize, groupsep)
	-- order of groups:
	-- - explicit keys
	--   - keys with simple values
	--   - keys with structure values (table with only explicit keys)
	--   - keys with mixed values (table with both exiplicit and implicit keys)
	--   - keys with array values (table with only implicit keys)
	-- - set part (explicit key with boolean value)
	-- - implicit keys
	-- order within a group:
	-- - string keys in lexicographic order
	-- - numbers in increasing order
	-- :TODO: handle tables as keys
	-- :TODO: handle sets
	
	-- extract implicit keys
	local implicit = {}
	for k,v in ipairs(table) do
		implicit[k] = true
	end
	-- categorize explicit keys
	local set = {}
	local simples = {}
	local structures = {}
	local mixeds = {}
	local arrays = {}
	for k,v in pairs(table) do
		if not implicit[k] then
			if type(v)=='table' then
				if v[1]==nil then
					structures[k] = true
				else
					local implicit = {}
					for k in ipairs(v) do
						implicit[k] = true
					end
					local mixed = false
					for k in pairs(v) do
						if not implicit[k] then
							mixed = true
							break
						end
					end
					if mixed then
						mixeds[k] = true
					else
						arrays[k] = true
					end
				end
			else
				simples[k] = true
			end
		end
	end
	
	local success,err,state
	if groupsize and groupsep then
		state = {
			i = 0,
			size = groupsize,
			sep = groupsep,
		}
	end
	success,err = dumptablesection(table, write, level, simples, state)
	if not success then return nil,err end
	success,err = dumptablesection(table, write, level, structures, state)
	if not success then return nil,err end
	success,err = dumptablesection(table, write, level, mixeds, state)
	if not success then return nil,err end
	success,err = dumptablesection(table, write, level, arrays, state)
	if not success then return nil,err end
	success,err = dumptableimplicitsection(table, write, level, state)
	if not success then return nil,err end
	return true
	
	--[[
	local done = {}
	for k,v in ipairs(table) do
		local success,err = dumppair(nil, v, write, level)
		if not success then return nil,err end
		done[k] = true
	end
	for k,v in pairs(table) do
		if not done[k] then
			local success,err = dumppair(k, v, write, level)
			if not success then return nil,err end
			done[k] = true
		end
	end
	return true
	--]]
end

function _M.tostring(value)
	local t = {}
	local success,err = dumpvalue(value, function(str) table.insert(t, str); return true end, 0)
	if not success then return nil,err end
	return table.concat(t)
end

function _M.tofile(value, file)
	local filename
	if type(file)=='string' then
		filename = file
		file = nil
	end
	local success,err
	if filename then
		file,err = io.open(filename, 'wb')
		if not file then return nil,err end
	end
	success,err = file:write"return "
	if not success then return nil,err end
	success,err = dumpvalue(value, function(...) return file:write(...) end, 0)
	if not success then return nil,err end
	success,err = file:write("\n-- v".."i: ft=lua\n")
	if not success then return nil,err end
	if filename then
		success,err = file:close()
		if not success then return nil,err end
	end
	return true
end

function _M.tofile_safe(value, filename, oldsuffix)
	local lfs = require 'lfs'
	
	if oldsuffix and lfs.attributes(filename, 'mode') then
		local i,suffix = 0,oldsuffix
		while io.open(filename..suffix, "rb") do
			i = i+1
			suffix = oldsuffix..i
		end
		assert(os.rename(filename, filename..suffix))
	end
	local tmpfilename = filename..'.new'
	local err,file,success
	file,err = io.open(tmpfilename, "wb")
	if not file then return nil,err end
	success,err = _M.tofile(value, file)
	if not success then
		file:close()
		os.remove(tmpfilename)
		return nil,err
	end
	success,err = file:close()
	if not success then
		os.remove(tmpfilename)
		return nil,err
	end
	if lfs.attributes(filename, 'mode') then
		assert(os.remove(filename))
	end
	assert(os.rename(tmpfilename, filename))
	return true
end

if _NAME=='test' then
	local str = [[
return {
	Abc = false,
	FOO = 42,
	Foo = "42",
	abc = true,
	["f O"] = 42,
	fOO = 42,
	foo = "42",
	[-1] = 37,
	[0] = 37,
	[42] = 37,
	Bar = {
		foo = 142,
	},
	bar = {
		foo = 142,
	},
	Baz = {
		foo = 242,
		237,
	},
	baz = {
		foo = 242,
		237,
	},
	Baf = {
		337,
	},
	baf = {
		337,
	},
	37,
}
-- v]]..[[i: ft=lua
]]
	local t
	if _VERSION=="Lua 5.1" then
		t = assert(loadstring(str))()
	elseif _VERSION=="Lua 5.2" then
		t = assert(load(str))()
	else
		error("unsupported Lua version")
	end

end

DUMP = _M
end
		</span>
		
		
		<script src="vendors/zip.js/WebContent/zip.js"></script>
		<script src="vendors/zip.js/WebContent/inflate.js"></script>
		<script src="vendors/zip.js/WebContent/deflate.js"></script>
		<script src="vendors/zip.js/WebContent/zip-fs.js"></script>
		<script src="vendors/weblua/build/weblua-0.1.5.js"></script>
		<script src="vendors/jquery/dist/jquery.min.js"></script>
		<script src="vendors/spark-md5/spark-md5.min.js"></script>
		<script src="vendors/stringview/stringview.js"></script>
		
		<script src="js/luautil.js"></script>
		<script src="js/admintool.js"></script>
		
	</body>
</html>
